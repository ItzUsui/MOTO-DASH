#!/usr/bin/env python3
import sys
import math
import pygame
from pygame.locals import *

# "Design resolution" (square) for our dash
VIRTUAL_SIZE = 800

# We'll draw everything on a 800x800 surface, then scale to the real screen.
DASH_CENTER = VIRTUAL_SIZE // 2

# Colors
BLACK  = (0,   0,   0)
GRAY   = (40,  40,  40)
WHITE  = (255, 255, 255)
RED    = (255, 0,   0)

##############################################################################
# ARC/Polygon Helpers
##############################################################################

def build_arc_polygon(angle_start_deg, angle_end_deg, outer_radius, thickness, steps=360):
    """
    Build a polygon covering the arc region from angle_start_deg to angle_end_deg
    (in degrees), with an outer radius and a certain thickness. We use a high
    'steps' for smoother arcs (360 => 1° increments).
    
    Returns a list of (x,y) points in CCW order suitable for pygame.draw.polygon().
    
    We'll assume angles increase clockwise from the top. That means:
      top = 0°, right = 90°, bottom = 180°, left = 270° (a typical "dashboard" angle system).
    But Pygame's default is 0° at +x axis, going CCW. We'll do a conversion below.
    """
    # Outer boundary: move from angle_start to angle_end in small increments
    pts = []
    step_size = (angle_end_deg - angle_start_deg) / steps
    
    # Build the outer boundary
    for i in range(steps+1):
        a_deg = angle_start_deg + i*step_size
        # Convert to Pygame's system: 0°=+x, CCW. We want a 0°=top, clockwise approach.
        # Let's define a function deg_to_radians(d) that does this transform:
        rads = math.radians(-a_deg + 90)  # shift so top=0, flip sign to go clockwise
        x_out = DASH_CENTER + outer_radius * math.cos(rads)
        y_out = DASH_CENTER - outer_radius * math.sin(rads)
        pts.append((x_out, y_out))
    
    # Inner boundary: go back from angle_end to angle_start
    for i in range(steps+1):
        a_deg = angle_end_deg - i*step_size
        rads = math.radians(-a_deg + 90)
        inner_r = outer_radius - thickness
        x_in = DASH_CENTER + inner_r * math.cos(rads)
        y_in = DASH_CENTER - inner_r * math.sin(rads)
        pts.append((x_in, y_in))
    
    return pts


def draw_smooth_arc(surface, angle_start, angle_end, outer_radius, thickness, color, overlap=0.0):
    """
    Draw a single arc polygon from angle_start to angle_end in 'color'.
    'overlap' can be a small angle to overlap with any adjacent arcs (avoid gaps).
    """
    # If angle_end < angle_start, swap them
    if angle_end < angle_start:
        angle_start, angle_end = angle_end, angle_start
    
    # Expand the arc a bit on each side to hide any boundary gap
    arc_pts = build_arc_polygon(angle_start - overlap,
                                angle_end   + overlap,
                                outer_radius,
                                thickness,
                                steps=360)
    pygame.draw.polygon(surface, color, arc_pts)


##############################################################################
# "S1000RR-Style" Tach with No Gaps
##############################################################################

def draw_tach_arc(surface, rpm, max_rpm=16000):
    """
    Draw a large tach arc from ~140° to ~400° (260° sweep), with:
     - A gray background arc
     - A white fill up to the redline
     - A red fill above redline
    We'll slightly overlap arcs to avoid scratchy lines.
    """
    angle_start = 140
    angle_end   = 400
    angle_range = angle_end - angle_start
    outer_r     = 350
    thickness   = 50
    overlap_deg = 0.2  # small overlap to hide gaps

    # 1) Gray background from 140..400
    draw_smooth_arc(surface, angle_start, angle_end, outer_r, thickness, GRAY)

    # Current "needle" angle
    frac = min(rpm/max_rpm, 1.0)
    needle_angle = angle_start + frac * angle_range
    
    # Let's define a redline at ~14k (0.875 * max_rpm)
    redline_rpm = 14000
    redline_frac = redline_rpm / float(max_rpm)
    redline_angle = angle_start + redline_frac * angle_range

    if rpm <= redline_rpm:
        # 2) White fill from 140..needle
        draw_smooth_arc(surface, angle_start, needle_angle, outer_r, thickness, WHITE, overlap=overlap_deg)
    else:
        # 2a) White fill from 140..redline
        draw_smooth_arc(surface, angle_start, redline_angle, outer_r, thickness, WHITE, overlap=overlap_deg)
        # 2b) Red fill from redline..needle
        draw_smooth_arc(surface, redline_angle, needle_angle, outer_r, thickness, RED, overlap=overlap_deg)


##############################################################################
# Other Minimal Dash Elements
##############################################################################

def draw_speed(surface, speed_kmh):
    """Large numeric speed near center."""
    try:
        font_speed = pygame.font.Font(None, 100)
    except:
        font_speed = pygame.font.Font(None, 100)
    
    spd_str = f"{int(speed_kmh)}"
    surf = font_speed.render(spd_str, True, WHITE)
    rect = surf.get_rect(center=(DASH_CENTER, DASH_CENTER + 40))
    surface.blit(surf, rect)

    # "km/h" below it
    font_unit = pygame.font.Font(None, 36)
    unit_surf = font_unit.render("km/h", True, WHITE)
    unit_rect = unit_surf.get_rect(midtop=(rect.centerx, rect.bottom - 5))
    surface.blit(unit_surf, unit_rect)


def draw_gear(surface, gear):
    """Simple gear indicator on the left side."""
    try:
        font_gear = pygame.font.Font(None, 80)
    except:
        font_gear = pygame.font.Font(None, 80)

    gear_str = str(gear)
    surf = font_gear.render(gear_str, True, WHITE)
    rect = surf.get_rect(center=(DASH_CENTER - 200, DASH_CENTER + 30))
    surface.blit(surf, rect)


##############################################################################
# Main "Draw Dashboard" function (on 800x800 Surface)
##############################################################################

def draw_dashboard(dash_surf, rpm, max_rpm, speed_kmh, gear):
    """Draws all dash elements onto our 800x800 dash_surf."""
    # 1) Clear
    dash_surf.fill(BLACK)
    # 2) Tach arc
    draw_tach_arc(dash_surf, rpm, max_rpm)
    # 3) Speed
    draw_speed(dash_surf, speed_kmh)
    # 4) Gear
    draw_gear(dash_surf, gear)


##############################################################################
# Main Loop with AUTO-FIT
##############################################################################

def main():
    pygame.init()
    
    # 1) Get current display resolution and go fullscreen
    info = pygame.display.Info()
    screen_w, screen_h = info.current_w, info.current_h
    # For testing in a window, comment out FULLSCREEN:
    # screen = pygame.display.set_mode((screen_w, screen_h), pygame.FULLSCREEN)
    screen = pygame.display.set_mode((screen_w, screen_h))
    
    pygame.display.set_caption("S1000RR-Style Dash: No Gaps, Auto-Fit")

    # 2) Create a "virtual" dash surface (800x800)
    dash_surf = pygame.Surface((VIRTUAL_SIZE, VIRTUAL_SIZE))

    clock = pygame.time.Clock()

    # Simulated data
    rpm = 0
    max_rpm = 16000
    speed_kmh = 0
    gear_list = ['N','1','2','3','4','5','6']
    gear_idx = 0
    
    rpm_dir = 1
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                running = False

        # Simulate some data
        if rpm >= max_rpm:
            rpm_dir = -1
        elif rpm <= 0:
            rpm_dir = 1
        rpm += rpm_dir * 200  # ramp up/down
        speed_kmh = rpm / 100.0

        # Cycle gear when rpm hits ~0
        if rpm < 10 and rpm_dir == 1:
            gear_idx = (gear_idx + 1) % len(gear_list)
        current_gear = gear_list[gear_idx]

        # Draw the 800x800 dash
        draw_dashboard(dash_surf, rpm, max_rpm, speed_kmh, current_gear)

        # Smooth-scale it to fill the real screen
        scaled_dash = pygame.transform.smoothscale(dash_surf, (screen_w, screen_h))
        screen.blit(scaled_dash, (0,0))

        pygame.display.flip()
        clock.tick(30)

    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()

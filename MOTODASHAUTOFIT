#!/usr/bin/env python3
import sys
import math
import pygame
from pygame.locals import *

# 1080×1080 round screen
SCREEN_WIDTH  = 1080
SCREEN_HEIGHT = 1080
CENTER_X = SCREEN_WIDTH // 2
CENTER_Y = SCREEN_HEIGHT // 2

RADIUS   = 540  # Outer circumference

# We'll assume a top speed of 200 mph for demonstration
MAX_SPEED = 200.0

# Colors
BLACK   = (0,   0,   0)
WHITE   = (255, 255, 255)
GREEN   = (0,   200, 0)
YELLOW  = (255, 220, 0)
RED     = (255, 0,   0)
GRAY    = (60,  60,  60)

###############################################################################
# ARC / Polygon Helpers
###############################################################################

def build_arc_polygon(angle_start_deg, angle_end_deg, outer_radius, thickness, steps=360):
    """
    Returns a list of (x,y) points forming a polygon for an arc spanning angle_start_deg
    to angle_end_deg, with an outer radius and 'thickness'. We use a "dashboard" angle
    system: 0° at top, increasing clockwise.
    """
    pts = []
    step_size = (angle_end_deg - angle_start_deg) / steps

    # Outer boundary
    for i in range(steps+1):
        a_deg = angle_start_deg + i * step_size
        rads = math.radians(-a_deg + 90)  # convert to Pygame coords
        x_out = CENTER_X + outer_radius * math.cos(rads)
        y_out = CENTER_Y - outer_radius * math.sin(rads)
        pts.append((x_out, y_out))

    # Inner boundary
    inner_radius = outer_radius - thickness
    for i in range(steps+1):
        a_deg = angle_end_deg - i * step_size
        rads = math.radians(-a_deg + 90)
        x_in = CENTER_X + inner_radius * math.cos(rads)
        y_in = CENTER_Y - inner_radius * math.sin(rads)
        pts.append((x_in, y_in))

    return pts

def draw_arc_segment(surface, a_start, a_end, outer_radius, thickness, color, overlap_deg=0.0):
    """
    Draw one arc segment from a_start to a_end, with given thickness/color.
    overlap_deg can expand each side slightly to hide gaps between segments.
    """
    if a_end < a_start:
        a_start, a_end = a_end, a_start
    arc_pts = build_arc_polygon(a_start - overlap_deg,
                                a_end   + overlap_deg,
                                outer_radius,
                                thickness,
                                steps=360)
    pygame.draw.polygon(surface, color, arc_pts)

###############################################################################
# Speedometer
###############################################################################

def draw_speedometer(surface, speed):
    """
    Speedometer arc from 150°..390° (240° sweep), radius=540 (touching screen edge).
    White border, then black track, then segmented fill (green->yellow->red).
    Ticks pass from outer border (540) to inner radius (460), with numeric labels
    inside (just smaller than 460).
    """

    angle_start = 150
    angle_end   = 390
    angle_range = angle_end - angle_start

    # Outer radius & bar thickness
    outer_r   = RADIUS       # 540
    thickness = 80           # bar thickness
    overlap   = 0.2          # small angle overlap

    # 1) White outer border ring
    border_thickness = 10
    draw_arc_segment(surface, angle_start, angle_end, 
                     outer_r, border_thickness, WHITE)

    # 2) Main black track
    track_outer = outer_r - border_thickness  # 540 - 10 = 530
    track_thick = thickness - border_thickness  # e.g. 70
    if track_thick < 0:
        track_thick = 0
    draw_arc_segment(surface, angle_start, angle_end,
                     track_outer, track_thick, BLACK)

    # 3) Colored fill (green->yellow->red at fraction 0.5, 0.8, 1.0)
    frac = min(max(speed / MAX_SPEED, 0.0), 1.0)
    fill_angle = angle_start + frac * angle_range

    green_frac = 0.5
    yellow_frac= 0.8
    green_angle = angle_start + green_frac * angle_range
    yellow_angle= angle_start + yellow_frac* angle_range

    fill_outer = track_outer
    fill_thick = track_thick

    # green zone
    if fill_angle > angle_start:
        end_a = min(fill_angle, green_angle)
        draw_arc_segment(surface, angle_start, end_a, fill_outer, fill_thick, GREEN, overlap_deg=overlap)
    # yellow
    if fill_angle > green_angle:
        end_a = min(fill_angle, yellow_angle)
        draw_arc_segment(surface, green_angle, end_a, fill_outer, fill_thick, YELLOW, overlap_deg=overlap)
    # red
    if fill_angle > yellow_angle:
        draw_arc_segment(surface, yellow_angle, fill_angle, fill_outer, fill_thick, RED, overlap_deg=overlap)

    # 4) Ticks
    draw_speed_ticks(
        surface,
        angle_start, angle_end,
        outer_r, thickness,
        major_step=20,
        minor_step=10,
        max_speed=MAX_SPEED,
        color=WHITE
    )

def draw_speed_ticks(surface, angle_start, angle_end, outer_r, bar_thickness,
                     major_step=20, minor_step=10, max_speed=200, color=WHITE):
    """
    Draws tick lines that start at outer_r (white border, 540) and go
    through the bar to the bar's inner radius (outer_r - bar_thickness = 460).
    The major ticks (every 20 mph) have numeric labels, placed just inside
    the bar's inner radius (~ 445).
    """

    angle_range = angle_end - angle_start
    # The bar’s inner radius = outer_r - bar_thickness
    bar_inner = outer_r - bar_thickness  # e.g. 540 - 80 = 460

    # We'll define the tick line from outer_r => bar_inner
    # Then label around bar_inner - 15 => e.g. 445
    label_radius = bar_inner - 15

    font_label = pygame.font.Font(None, 36)

    def speed_to_angle(spd):
        frac = spd / float(max_speed)
        return angle_start + frac * angle_range

    spd = 0
    while spd <= max_speed + 0.1:
        a_deg = speed_to_angle(spd)
        rads  = math.radians(-a_deg + 90)

        # major if it's divisible by major_step or near max_speed
        if (abs(spd % major_step) < 0.0001) or (abs(spd - max_speed) < 0.001):
            thick_line = 3
            do_label = True
        else:
            thick_line = 2
            do_label = False

        x_outer = CENTER_X + outer_r * math.cos(rads)    # 540
        y_outer = CENTER_Y - outer_r * math.sin(rads)
        x_inner = CENTER_X + bar_inner * math.cos(rads)  # 460
        y_inner = CENTER_Y - bar_inner * math.sin(rads)

        # Draw the line
        pygame.draw.line(surface, color, (x_outer, y_outer), (x_inner, y_inner), thick_line)

        # If major => label
        if do_label:
            speed_str = str(int(spd))
            lbl_surf  = font_label.render(speed_str, True, color)
            lx = CENTER_X + label_radius * math.cos(rads)   # e.g. 445
            ly = CENTER_Y - label_radius * math.sin(rads)
            lbl_rect  = lbl_surf.get_rect(center=(lx, ly))
            surface.blit(lbl_surf, lbl_rect)

        spd += minor_step

###############################################################################
# Battery & Odometer
###############################################################################

def draw_battery_meter(surface, battery_level, x_center, y_top):
    """Small battery meter + XX% text."""
    w, h = 100, 20
    x = x_center - w//2
    y = y_top

    # Outline
    outline_rect = pygame.Rect(x, y, w, h)
    pygame.draw.rect(surface, WHITE, outline_rect, 2)

    # Fill
    fill_w = int((w-4) * battery_level)
    fill_rect = pygame.Rect(x+2, y+2, fill_w, h-4)
    color = GREEN if battery_level>0.2 else RED
    pygame.draw.rect(surface, color, fill_rect)

    font_batt = pygame.font.Font(None, 24)
    pct = int(battery_level*100)
    txt_surf = font_batt.render(f"{pct}%", True, WHITE)
    txt_rect = txt_surf.get_rect(midleft=(x + w + 20, y + h/2))
    surface.blit(txt_surf, txt_rect)

def draw_odometer(surface, odometer_mi, x_center, y_top):
    """Simple 'Odo: XXX.x' below battery meter."""
    font_odo = pygame.font.Font(None, 24)
    txt = f"Odo: {odometer_mi:.1f}"
    surf = font_odo.render(txt, True, WHITE)
    rect = surf.get_rect(midtop=(x_center, y_top))
    surface.blit(surf, rect)

###############################################################################
# Main Loop
###############################################################################

def main():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("1080p Round Dash - Enhanced Ticks")

    clock = pygame.time.Clock()

    # Simulated data
    speed = 0.0
    speed_dir = 1
    battery_level = 0.75
    odometer_val = 1234.5

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                running = False

        # Speed changes
        if speed >= MAX_SPEED:
            speed_dir = -1
        elif speed <= 0:
            speed_dir = 1
        speed += speed_dir * 1.5  # accelerate or decelerate

        # Odometer
        odometer_val += speed / 3600.0

        # Battery drain
        battery_level -= 0.0002
        if battery_level < 0:
            battery_level = 1.0

        # Clear
        screen.fill(BLACK)

        # Draw speedometer arc
        draw_speedometer(screen, speed)

        # Bigger speed number (font=140), same position
        try:
            font_speed = pygame.font.Font(None, 140)
        except:
            font_speed = pygame.font.Font(None, 140)

        spd_str = f"{int(speed)}"
        surf_spd = font_speed.render(spd_str, True, WHITE)
        rect_spd = surf_spd.get_rect(center=(CENTER_X, CENTER_Y+20))
        screen.blit(surf_spd, rect_spd)

        # mph label
        font_unit = pygame.font.Font(None, 36)
        unit_surf = font_unit.render("mph", True, WHITE)
        unit_rect = unit_surf.get_rect(midtop=(rect_spd.centerx, rect_spd.bottom - 5))
        screen.blit(unit_surf, unit_rect)

        # Battery & Odometer below speed
        battery_y = unit_rect.bottom + 20
        draw_battery_meter(screen, battery_level, CENTER_X, battery_y)
        draw_odometer(screen, odometer_val, CENTER_X, battery_y + 30)

        pygame.display.flip()
        clock.tick(30)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
